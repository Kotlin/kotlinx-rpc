package org.jetbrains.krpc.client

import org.jetbrains.krpc.RPC
import org.jetbrains.krpc.internal.RPCField
import org.jetbrains.krpc.internal.RPCServiceFieldsProvider
import org.jetbrains.krpc.internal.findRPCProviderInCompanion
import kotlin.reflect.KClass

/**
 * Waits for the initialization of an RPC field in the generated client:
 * ```kotlin
 * interface MyService : RPC {
 *     val stateFlow: StateFlow<Int>
 * }
 *
 * val client = RPC.clientOf<MyService>(transport)
 * val currentValue = client.awaitFieldInitialization { stateFlow }.value
 * ```
 */
suspend fun <T : RPC, R> T.awaitFieldInitialization(getter: T.() -> R): R {
    val field = getter()

    if (field is RPCField<*>) {
        @Suppress("UNCHECKED_CAST")
        return (field as RPCField<R>).await()
    }

    error("Please choose required field for a valid RPC client generated by a RPC.clientOf method")
}

/**
 * Waits for the initialization of all RPC fields in the generated client:
 * ```kotlin
 * interface MyService : RPC {
 *     val stateFlow1: StateFlow<Int>
 *     val stateFlow2: StateFlow<Int>
 * }
 *
 * val client = RPC.clientOf<MyService>(transport)
 * val currentValue = client.awaitFieldInitialization()
 * // fields `stateFlow1` and `stateFlow2` are initialized
 * ```
 */
suspend inline fun <reified T : RPC> T.awaitFieldInitialization(): T {
    return awaitFieldInitialization(T::class)
}

/**
 * Waits for the initialization of all RPC fields in the generated client:
 * ```kotlin
 * interface MyService : RPC {
 *     val stateFlow1: StateFlow<Int>
 *     val stateFlow2: StateFlow<Int>
 * }
 *
 * val client = RPC.clientOf<MyService>(transport)
 * val currentValue = client.awaitFieldInitialization(MyService::class)
 * // fields `stateFlow1` and `stateFlow2` are initialized
 * ```
 */
suspend fun <T : RPC> T.awaitFieldInitialization(kClass: KClass<T>): T {
    findRPCProviderInCompanion<RPCServiceFieldsProvider<T>>(kClass)
        .rpcFields(this)
        .forEach { field ->
            field.await()
        }

    return this
}
