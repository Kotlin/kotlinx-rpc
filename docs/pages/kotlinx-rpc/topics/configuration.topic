<?xml version="1.0" encoding="UTF-8"?>
<!--
  - Copyright 2023-2025 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.
  -->

<!DOCTYPE topic
        SYSTEM "https://resources.jetbrains.com/writerside/1.0/xhtml-entities.dtd">
<topic xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="https://resources.jetbrains.com/writerside/1.0/topic.v2.xsd"
       title="Configuration" id="configuration">
    <p>
        <code>KrpcConfig</code> is a class used to configure <code>KrpcClient</code> and <code>KrpcServer</code>
        (not to be confused with <code>RpcClient</code> and <code>RpcServer</code>).
    </p>
    <p>
        It has two children: <code>KrpcConfig.Client</code> and <code>KrpcConfig.Server</code>.
        <code>Client</code> and <code>Server</code> may have shared properties as well as distinct ones.
        To create instances of these configurations, DSL builders are provided:
    </p>
    <list>
        <li>
            <code>rpcClientConfig</code>
        </li>
        <li>
            <code>rpcServerConfig</code>
        </li>
    </list>

    <code-block lang="kotlin">
        val config: KrpcConfig.Client = rpcClientConfig { // same for KrpcConfig.Server with rpcServerConfig
            // configuration here
        }
    </code-block>
    <p>
        The following configuration options are available:
    </p>
    <chapter id="serialization-dsl">
        <title>
            <code>serialization</code> DSL
        </title>
        <p>
            This parameter defines how serialization should work in RPC services
            and is present in both client and server configurations.
        </p>
        <p>
            The serialization process is used to encode and decode data in RPC requests,
            so that the data can be transferred through the network.
        </p>
        <p>
            Currently only <code>StringFormat</code> and <code>BinaryFormat</code> from
            <a href="https://github.com/Kotlin/kotlinx.serialization">kotlinx.serialization</a> are supported,
            and by default you can choose from Json, Protobuf or Cbor formats:
        </p>

        <code-block lang="kotlin">
            rpcClientConfig {
                serialization {
                    json { /* this: JsonBuilder from kotlinx.serialization */ }
                    cbor { /* this: CborBuilder from kotlinx.serialization */ }
                    protobuf { /* this: ProtobufBuilder from kotlinx.serialization */ }
                }
            }
        </code-block>
        <p>
            Only last defined format will be used to serialize requests.
            If no format is specified, a runtime error will be thrown.
            You can also define a custom format.
        </p>
    </chapter>
    <chapter id="connector-dsl">
        <title>
            <code>connector</code> DSL
        </title>
        <p>
            Connector is a part of kRPC that is responsible for sending and receiving data over the network.
            You can configure the following parameters:
        </p>
        <list>
            <li>
                <code>waitTimeout</code> - timeout for waiting for a service to be registered.
                Sometimes services can be registered after the server starts,
                and after the first requests starts to arrive from a peer.
                This parameter defines how long the server will wait for a service to be registered.
                <br/>
                The default value is <code>Duration.INFINITE</code>.
                <br/>
                Also, available a value of <code>dontWait()</code>.
            </li>
            <li>
                <code>callTimeout</code> - timeout for processing one message.
                <br/>
                The default value is <code>Duration.INFINITE</code>.
            </li>
            <li>
                <code>perCallBufferSize</code> - size of the buffer for one call.
                Call can be a stream or a single message.
                This effectively provides a backpressure mechanism.
                If a peer is slow to process the message during a call,
                the buffer will be filled up and
                the sender will wait before sending more messages.
                <br/>
                Note that this is <b>per call</b>, not per connection.
                <br/>
                The default value is <code>1000</code>.
            </li>
        </list>
        <p>
            Example:
        </p>
        <code-block lang="kotlin">
            rpcClientConfig {
                connector {
                    waitTimeout = 10.seconds
                    callTimeout = 60.seconds
                    perCallBufferSize = 1000
                }
            }
        </code-block>
    </chapter>
</topic>
