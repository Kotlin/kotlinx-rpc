/*
 * Copyright 2023-2025 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.
 */

package util.tasks

import org.gradle.api.DefaultTask
import org.gradle.api.Project
import org.gradle.api.file.FileTree
import org.gradle.api.provider.ListProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.Copy
import org.gradle.api.tasks.Exec
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.InputFiles
import org.gradle.api.tasks.OutputFile
import org.gradle.api.tasks.TaskAction
import org.gradle.kotlin.dsl.accessors.runtime.addExternalModuleDependencyTo
import org.gradle.kotlin.dsl.dependencies
import org.gradle.kotlin.dsl.register
import org.gradle.kotlin.dsl.the
import org.jetbrains.kotlin.gradle.dsl.KotlinJvmExtension
import util.other.libs
import java.io.File

const val CONFORMANCE_TEST_RUNNER_CONFIGURATION = "conformanceTestRunner"
const val PROTOC_TESTING_CONFIGURATION = "protoc_internalTesting"
const val UNZIP_PROTOBUF_CONFORMANCE_TASK = "unzipProtobufConformance"
const val WRITE_CONFORMANCE_EXECUTABLE_PATH_TASK = "writeConformanceExecutablePath"
const val PAYLOAD_PB = "payload.pb"
const val CONFORMANCE_PB = "conformance.pb"

private fun Project.getBinFrom(configuration: String): File {
    return configurations.getByName(configuration).map {
        zipTree(it).matching { include("bin/**") }.files.first()
    }.single()
}

private fun Project.getIncludeFrom(configuration: String): List<FileTree> {
    return configurations.getByName(configuration).map {
        zipTree(it).matching { include("include/**") }
    }
}

private fun List<String>.commonPrefix(): String {
    return fold(first()) { acc, s -> acc.commonPrefixWith(s) }
}

private fun Project.pbFile(name: String): File {
    return layout.buildDirectory.get()
        .dir("protobuf-conformance")
        .file(name)
        .asFile
        .apply {
            if (!exists()) {
                parentFile.mkdirs()
                createNewFile()
            }
        }
}

abstract class ConformanceExecutablePathWriter : DefaultTask() {
    @get:Input
    abstract val outputDir: Property<File>

    @get:Input
    abstract val kotlinTestDir: Property<File>

    @get:InputFile
    abstract val executable: Property<File>

    @get:OutputFile
    abstract val destination: Property<File>

    @TaskAction
    fun action() {
        val dest = destination.get()
        if (dest.exists()) {
            dest.delete()
        }

        val parent = dest.parentFile
        if (!parent.exists()) {
            parent.mkdirs()
        }

        dest.writeText(
            """
            // file generated by ConformanceExecutablePathWriter task
            
            const val CONFORMANCE_EXECUTABLE_PATH: String = "${executable.get().absolutePath}"
            
            const val CONFORMANCE_OUTPUT_DIR: String = "${outputDir.get().absolutePath}"
            
            const val KOTLIN_TEST_DIR: String = "${kotlinTestDir.get().absolutePath}"
            
        """.trimIndent()
        )
    }
}

abstract class GenerateConformanceFileDescriptorSet : Exec() {
    @get:InputFiles
    abstract val wktFilesCollection: ListProperty<File>

    @get:InputFiles
    abstract val conformanceFilesCollection: ListProperty<File>

    @get:InputFile
    abstract val bin: Property<File>

    @get:OutputFile
    abstract val outputFile: Property<File>

    @TaskAction
    fun generate() {
        val wktFiles = wktFilesCollection.get().map { it.absolutePath }
        val conformanceFiles = conformanceFilesCollection.get().map { it.absolutePath }

        val wktProtoPath = if (wktFiles.isEmpty()) {
            emptyList()
        } else {
            listOf("--proto_path=${wktFiles.commonPrefix().substringBefore("/google/protobuf/")}")
        }

        val conformanceIncludeDir = conformanceFiles
            .commonPrefix()
            .substringBefore("/google/protobuf/")
            .substringBefore("/conformance/")

        val conformanceProtoPath = "--proto_path=$conformanceIncludeDir"

        commandLine(
            bin.get().absolutePath,
            *wktProtoPath.toTypedArray(),
            conformanceProtoPath,
            "-o", outputFile.get().absolutePath,
            *wktFiles.toTypedArray(),
            *conformanceFiles.toTypedArray(),
        )
    }
}

fun Project.setupProtobufConformanceResources() {
    val os = System.getProperty("os.name").lowercase()
    val osPart = when {
        os.startsWith("linux") -> "linux"
        os.startsWith("mac") -> "osx"
        else -> error("unsupported os for protobuf-conformance tests: $os")
    }

    val archPart = when (val arch = System.getProperty("os.arch").lowercase()) {
        in setOf("x86_64", "amd64", "aarch64") -> "x86_64"
        else -> error("unsupported arch for protobuf-conformance tests: $arch")
    }

    // https://stackoverflow.com/questions/23023069/gradle-download-and-unzip-file-from-url
    repositories.ivy {
        name = "github"
        url = uri("https://github.com")

        patternLayout {
            // https://github.com/bufbuild/protobuf-conformance/releases/download/v${version}/conformance_test_runner-${version}-${build}.zip
            artifact("[organisation]/[module]/releases/download/v[revision]/[artifact]-[revision]-[classifier].[ext]")
        }

        // This is required in Gradle 6.0+ as metadata file (ivy.xml)
        // is mandatory. Docs linked below this code section
        metadataSources { artifact() }
    }

    configurations.create(CONFORMANCE_TEST_RUNNER_CONFIGURATION)
    configurations.create(PROTOC_TESTING_CONFIGURATION)

    // https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/dsl/DependencyHandler.html
    dependencies {
        addExternalModuleDependencyTo(
            this,
            CONFORMANCE_TEST_RUNNER_CONFIGURATION,
            group = "bufbuild",
            name = "protobuf-conformance",
            version = libs.versions.protobuf.asProvider().get().substringAfter("."),
            classifier = null,
            ext = null,
            configuration = null,
        ) {
            artifact {
                name = "conformance_test_runner"
                type = "zip"
                extension = "zip"
                classifier = "$osPart-$archPart"
            }
        }
    }

    dependencies {
        addExternalModuleDependencyTo(
            this,
            PROTOC_TESTING_CONFIGURATION,
            group = "protocolbuffers",
            name = "protobuf",
            version = libs.versions.protobuf.asProvider().get().substringAfter("."),
            classifier = null,
            ext = null,
            configuration = null,
        ) {
            artifact {
                name = "protoc"
                type = "zip"
                extension = "zip"
                classifier = "$osPart-$archPart"
            }
        }
    }

    val unzipProtobufConformance = tasks.register<Copy>(UNZIP_PROTOBUF_CONFORMANCE_TASK) {
        from(getIncludeFrom(CONFORMANCE_TEST_RUNNER_CONFIGURATION))

        val destDir = project.layout.projectDirectory
            .dir("src")
            .dir("main")
            .dir("proto")

        into(destDir)

        eachFile {
            if (path.startsWith("include/")) {
                path = "protobuf-conformance/${path.removePrefix("include/")}"
            }
        }

        includeEmptyDirs = false

        doFirst {
            destDir.asFile.deleteRecursively()
        }
    }

    tasks.register<GenerateConformanceFileDescriptorSet>("generateConformanceFileDescriptorSet_conformance") {
        wktFilesCollection.set(emptyList())

        val conformanceFiles = project.getIncludeFrom(CONFORMANCE_TEST_RUNNER_CONFIGURATION).flatMap { it.files }
            .filter { it.name == "conformance.proto" }

        conformanceFilesCollection.set(conformanceFiles)

        bin.set(getBinFrom(PROTOC_TESTING_CONFIGURATION))

        outputFile.set(project.pbFile(CONFORMANCE_PB))
    }

    tasks.register<GenerateConformanceFileDescriptorSet>("generateConformanceFileDescriptorSet_payload") {
        val wktFiles = project.getIncludeFrom(PROTOC_TESTING_CONFIGURATION).flatMap { it.files }
        wktFilesCollection.set(wktFiles)

        // editions are not supported in protoscope and proto2 fails
        val conformanceFiles = project.getIncludeFrom(CONFORMANCE_TEST_RUNNER_CONFIGURATION).flatMap { it.files }
            .filter { it.name == "test_messages_proto3.proto" }

        conformanceFilesCollection.set(conformanceFiles)

        bin.set(getBinFrom(PROTOC_TESTING_CONFIGURATION))

        outputFile.set(project.pbFile(PAYLOAD_PB))
    }

    val writeConformanceExecutablePath =
        tasks.register<ConformanceExecutablePathWriter>(WRITE_CONFORMANCE_EXECUTABLE_PATH_TASK) {
            outputDir.set(
                project.layout.buildDirectory.get()
                    .dir("protobuf-conformance")
                    .asFile
            )

            kotlinTestDir.set(
                project.layout.projectDirectory
                    .dir("src")
                    .dir("test")
                    .dir("kotlin")
                    .asFile
            )

            executable.set(getBinFrom(CONFORMANCE_TEST_RUNNER_CONFIGURATION))

            destination.set(
                project.layout.buildDirectory.get()
                    .dir("generated")
                    .dir("protobuf-conformance")
                    .file("executable-paths.kt")
                    .asFile
            )
        }

    tasks.matching { it.name == "processMainProtoFiles" || it.name == "processTestImportProtoFiles" }.all {
        dependsOn(unzipProtobufConformance)
    }

    the<KotlinJvmExtension>().apply {
        sourceSets.getByName("main") {
            kotlin.srcDir(writeConformanceExecutablePath.map { it.destination.get().parentFile })
        }
    }
}
