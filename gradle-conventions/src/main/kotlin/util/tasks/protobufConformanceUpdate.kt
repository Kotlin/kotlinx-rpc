/*
 * Copyright 2023-2025 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.
 */

package util.tasks

import org.gradle.api.DefaultTask
import org.gradle.api.Project
import org.gradle.api.provider.Property
import org.gradle.api.tasks.Copy
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.OutputFile
import org.gradle.api.tasks.TaskAction
import org.gradle.kotlin.dsl.accessors.runtime.addExternalModuleDependencyTo
import org.gradle.kotlin.dsl.dependencies
import org.gradle.kotlin.dsl.register
import org.gradle.kotlin.dsl.the
import org.jetbrains.kotlin.gradle.dsl.KotlinJvmExtension
import util.other.libs
import java.io.File

const val CONFORMANCE_TEST_RUNNER_CONFIGURATION = "conformanceTestRunner"
const val UNZIP_PROTOBUF_CONFORMANCE_TASK = "unzipProtobufConformance"
const val WRITE_CONFORMANCE_EXECUTABLE_PATH_TASK = "writeConformanceExecutablePath"

abstract class ConformanceExecutablePathWriter : DefaultTask() {
    @get:InputFile
    abstract val executable: Property<File>

    @get:OutputFile
    abstract val destination: Property<File>

    @TaskAction
    fun action() {
        val dest = destination.get()
        if (dest.exists()) {
            dest.delete()
        }

        val parent = dest.parentFile
        if (!parent.exists()) {
            parent.mkdirs()
        }

        dest.writeText(
            """
            // file generated by ConformanceExecutablePathWriter task
            
            const val CONFORMANCE_EXECUTABLE_PATH: String = "${executable.get().absolutePath}"

        """.trimIndent()
        )
    }
}

fun Project.setupProtobufConformanceResources() {
    val os = System.getProperty("os.name").lowercase()
    val osPart = when {
        os.startsWith("linux") -> "linux"
        os.startsWith("mac") -> "osx"
        else -> error("unsupported os for protobuf-conformance tests: $os")
    }

    val archPart = when (val arch = System.getProperty("os.arch").lowercase()) {
        in setOf("x86_64", "amd64", "aarch64") -> "x86_64"
        else -> error("unsupported arch for protobuf-conformance tests: $arch")
    }

    // https://stackoverflow.com/questions/23023069/gradle-download-and-unzip-file-from-url
    repositories.ivy {
        name = "protobuf-conformance-github"
        url = uri("https://github.com")

        patternLayout {
            // https://github.com/bufbuild/protobuf-conformance/releases/download/v${version}/conformance_test_runner-${version}-${build}.zip
            artifact("[organisation]/[module]/releases/download/v[revision]/[artifact]-[revision]-[classifier].[ext]")
        }

        // This is required in Gradle 6.0+ as metadata file (ivy.xml)
        // is mandatory. Docs linked below this code section
        metadataSources { artifact() }
    }

    configurations.create(CONFORMANCE_TEST_RUNNER_CONFIGURATION)

    // https://docs.gradle.org/current/javadoc/org/gradle/api/artifacts/dsl/DependencyHandler.html
    dependencies {
        addExternalModuleDependencyTo(
            this,
            CONFORMANCE_TEST_RUNNER_CONFIGURATION,
            group = "bufbuild",
            name = "protobuf-conformance",
            version = libs.versions.protobuf.asProvider().get().substringAfter("."),
            classifier = null,
            ext = null,
            configuration = null,
        ) {
            artifact {
                name = "conformance_test_runner"
                type = "zip"
                extension = "zip"
                classifier = "$osPart-$archPart"
            }
        }
    }

    val unzipProtobufConformance = tasks.register<Copy>(UNZIP_PROTOBUF_CONFORMANCE_TASK) {
        from(configurations.getByName(CONFORMANCE_TEST_RUNNER_CONFIGURATION).map {
            zipTree(it).matching { include("include/**") }
        })

        val destDir = project.layout.projectDirectory
            .dir("src")
            .dir("test")
            .dir("proto")

        into(destDir)

        eachFile {
            if (path.startsWith("include/")) {
                path = "protobuf-conformance/${path.removePrefix("include/")}"
            }
        }

        includeEmptyDirs = false

        doFirst {
            destDir.asFile.deleteRecursively()
        }
    }

    val writeConformanceExecutablePath =
        tasks.register<ConformanceExecutablePathWriter>(WRITE_CONFORMANCE_EXECUTABLE_PATH_TASK) {
            executable.set(
                configurations.getByName(CONFORMANCE_TEST_RUNNER_CONFIGURATION).map {
                    zipTree(it).matching { include("bin/**") }.files.first()
                }.single()
            )

            destination.set(
                project.layout.buildDirectory.file("generated/protobuf-conformance/executable-path.kt").get().asFile
            )
        }

    tasks.matching { it.name == "processTestProtoFiles" }.all {
        dependsOn(unzipProtobufConformance)
    }

    the<KotlinJvmExtension>().apply {
        sourceSets.getByName("test") {
            kotlin.srcDir(writeConformanceExecutablePath.map { it.destination.get().parentFile })
        }
    }
}
